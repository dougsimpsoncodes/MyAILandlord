# The Clerk-Supabase Integration Challenge: A Debugging Journey

## Executive Summary
This document chronicles our attempts to integrate Clerk authentication with Supabase Row Level Security (RLS) in a React Native/Expo application. Despite following official documentation and implementing multiple solutions, we continue to face persistent JWT token validation issues that prevent proper user authentication and data access.

## The Challenge

### Core Problem
We're building MyAILandlord, a property management app that uses:
- **Clerk** for authentication (user signup, login, session management)
- **Supabase** for the database with Row Level Security (RLS) policies
- **React Native/Expo** for the mobile application

The integration should allow Clerk-authenticated users to access their data in Supabase through RLS policies that validate JWT tokens. However, the JWT tokens from Clerk are not being properly recognized by Supabase's RLS system.

### Expected Behavior
1. User authenticates with Clerk
2. Clerk generates a JWT token with user claims
3. Supabase receives the JWT token in API requests
4. RLS policies extract the user ID from the JWT
5. Users can only access their own data

### Actual Behavior
- JWT tokens are generated by Clerk
- Tokens are sent to Supabase in request headers
- RLS policies fail to extract user information from tokens
- All database operations are blocked with "permission denied" errors
- `auth.current_user_id()` returns NULL in RLS policies

## Timeline of Debugging Attempts

### Phase 1: Initial Setup (Day 1)
**Approach:** Follow official Clerk documentation for Supabase integration

**Actions Taken:**
1. Created JWT template in Clerk dashboard named "supabase"
2. Configured template with RS256 algorithm and required claims:
   ```json
   {
     "sub": "{{user.id}}",
     "email": "{{user.primary_email_address.email_address}}",
     "aud": "authenticated",
     "iat": "{{token.iat}}",
     "exp": "{{token.exp}}"
   }
   ```
3. Set up Supabase client with custom `accessToken` function:
   ```typescript
   global: {
     accessToken: async () => await getToken({ template: 'supabase' })
   }
   ```

**Result:** ❌ RLS policies still blocking access, JWT not recognized

### Phase 2: RLS Policy Refinement (Day 2)
**Hypothesis:** The RLS policies aren't correctly extracting the user ID from JWT

**Actions Taken:**
1. Created custom SQL function `auth.current_user_id()`:
   ```sql
   CREATE OR REPLACE FUNCTION auth.current_user_id()
   RETURNS TEXT
   LANGUAGE SQL
   SECURITY DEFINER
   AS $$
     SELECT COALESCE(
       current_setting('request.jwt.claims->>sub', true),
       current_setting('request.jwt.claims->>user_id', true)
     );
   $$;
   ```

2. Updated all RLS policies to use the new function:
   ```sql
   CREATE POLICY "clerk_select_profile" ON profiles
   FOR SELECT
   USING (clerk_user_id = auth.current_user_id());
   ```

3. Granted necessary permissions:
   ```sql
   GRANT EXECUTE ON FUNCTION auth.current_user_id() TO anon, authenticated;
   ```

**Result:** ❌ Function returns NULL, JWT claims not accessible

### Phase 3: Alternative JWT Extraction Methods (Day 3)
**Hypothesis:** Maybe we need to use Supabase's built-in JWT functions

**Actions Taken:**
1. Tested multiple JWT extraction approaches:
   - `auth.jwt()->>'sub'` - Supabase's native JWT function
   - `current_setting('request.jwt.claims->>sub', true)` - PostgreSQL settings
   - `auth.uid()` - Supabase's user ID function
   - Combined COALESCE approach for fallback

2. Created debug function to inspect JWT:
   ```sql
   CREATE OR REPLACE FUNCTION debug_jwt_claims()
   RETURNS json
   LANGUAGE sql
   SECURITY DEFINER
   AS $$
     SELECT auth.jwt();
   $$;
   ```

**Result:** ❌ Debug function returns NULL, no JWT detected by Supabase

### Phase 4: Client-Side Authentication Hook (Day 4)
**Hypothesis:** Maybe the client isn't sending tokens correctly

**Actions Taken:**
1. Created custom React hook `useAuthenticatedSupabase`:
   ```typescript
   export function useAuthenticatedSupabase() {
     const { getToken, isSignedIn, user } = useAuth();
     
     const supabase = createClient(url, key, {
       global: {
         accessToken: async () => {
           if (!isSignedIn) return null;
           return await getToken({ template: 'supabase' });
         }
       }
     });
     
     return { client: new SupabaseClient(supabase), isAuthenticated, user };
   }
   ```

2. Updated all components to use the authenticated client
3. Added extensive logging to verify token generation

**Result:** ✅ Tokens are being generated client-side
         ❌ But still not recognized by Supabase RLS

### Phase 5: Manual Token Injection (Day 5)
**Hypothesis:** Maybe we need to explicitly set the Authorization header

**Actions Taken:**
1. Attempted manual header setting:
   ```typescript
   const token = await getToken({ template: 'supabase' });
   const { data, error } = await supabase
     .from('profiles')
     .select('*')
     .headers({ Authorization: `Bearer ${token}` });
   ```

2. Verified token format and content:
   - Decoded JWT payload to ensure correct claims
   - Confirmed token is valid RS256 JWT
   - Checked expiration times

**Result:** ❌ Headers are sent but RLS still doesn't recognize the user

### Phase 6: Workaround - Explicit User ID (Current State)
**Temporary Solution:** Pass user ID explicitly in queries

**Implementation:**
1. All INSERT operations explicitly set `clerk_user_id`:
   ```typescript
   await supabase.from('profiles').insert({
     clerk_user_id: user.id,  // Explicitly set
     email: user.email,
     // ... other fields
   });
   ```

2. Created more permissive RLS policies for debugging:
   ```sql
   CREATE POLICY "Users can insert own profile" ON profiles
   FOR INSERT
   TO authenticated
   WITH CHECK (
     clerk_user_id = COALESCE(
       auth.jwt()->>'sub',
       current_setting('request.jwt.claims->>sub', true)
     )
   );
   ```

**Result:** ⚠️ Partial success - INSERT works when explicitly passing ID
         ❌ SELECT/UPDATE/DELETE still blocked by RLS

## Key Discoveries

### What Works
1. ✅ Clerk authentication and user management
2. ✅ JWT token generation with correct claims
3. ✅ Supabase connection without RLS
4. ✅ INSERT operations when explicitly passing clerk_user_id

### What Doesn't Work
1. ❌ JWT token validation in Supabase RLS policies
2. ❌ Automatic user context from JWT claims
3. ❌ SELECT/UPDATE/DELETE operations with RLS enabled
4. ❌ `auth.jwt()` and related functions return NULL

### Suspected Root Causes

1. **JWT Secret Mismatch**
   - Clerk uses RS256 (asymmetric) signing
   - Supabase might expect HS256 (symmetric) by default
   - Public key from Clerk might not be properly configured in Supabase

2. **Token Transport Issue**
   - Token might not be reaching PostgreSQL RLS layer
   - Possible middleware stripping or modifying headers
   - Supabase client might not be sending token in expected format

3. **Supabase Configuration**
   - JWT secret might need manual configuration in Supabase
   - Custom claims might need special handling
   - Role/audience claims might be validated differently

## Current Workarounds

### 1. Disable RLS (Not Recommended)
```sql
ALTER TABLE profiles DISABLE ROW LEVEL SECURITY;
```
- ⚠️ Security risk: All users can access all data
- Only for development/debugging

### 2. Service Role Key (Server-Side Only)
```typescript
const supabase = createClient(url, SERVICE_ROLE_KEY);
```
- ⚠️ Cannot be used in client applications
- Bypasses RLS entirely

### 3. Explicit User ID Passing
```typescript
// Pass user ID in every query
const { data } = await supabase
  .from('profiles')
  .select('*')
  .eq('clerk_user_id', user.id);
```
- ⚠️ No automatic security enforcement
- Requires careful implementation

## Next Steps to Try

### 1. Configure Supabase JWT Secret
- [ ] Get Clerk's public key for RS256 verification
- [ ] Configure in Supabase Dashboard > Settings > Auth
- [ ] Test with curl to verify JWT validation

### 2. Custom Supabase Edge Function
- [ ] Create edge function to validate Clerk tokens
- [ ] Set custom claims in Supabase session
- [ ] Use Supabase's native auth for RLS

### 3. Alternative Architecture
- [ ] Consider using Supabase Auth instead of Clerk
- [ ] Implement custom middleware for token translation
- [ ] Use database triggers instead of RLS for some operations

## Lessons Learned

1. **Integration Complexity**: Third-party auth + RLS is non-trivial
2. **Documentation Gaps**: Official docs don't cover all edge cases
3. **Debugging Difficulty**: RLS policies are hard to debug (no logs)
4. **Token Standards**: JWT implementations vary between providers
5. **Testing Importance**: Need isolated tests for each integration layer

## Resources & References

- [Clerk JWT Templates Docs](https://clerk.com/docs/backend-requests/making/jwt-templates)
- [Supabase RLS Guide](https://supabase.com/docs/guides/auth/row-level-security)
- [Supabase Custom Claims](https://supabase.com/docs/guides/auth/jwts#adding-custom-claims)
- [Our Debug Guide](./CLERK_SUPABASE_INTEGRATION_DEBUG.md)
- [Migration Scripts](./migrations/2025-08-13_profiles_rls.sql)

## Conclusion

The Clerk-Supabase integration presents significant challenges, primarily around JWT token validation in RLS policies. While we've found workarounds for basic functionality, a proper solution requires either:

1. Correct JWT secret/key configuration in Supabase
2. Custom authentication middleware
3. Alternative architecture decisions

The debugging journey has revealed the complexity of integrating two authentication systems and highlighted the importance of thorough testing and documentation when working with security-critical components.

---

*Document created: August 14, 2025*
*Status: Ongoing Investigation*
*Priority: Critical - Blocking Production Release*